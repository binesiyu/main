" Pathogen or Vundle (deafult is Vundle) {{{

" Comment-out if you want to use pahogen
" execute pathogen#infect()
" com! -nargs=+ Bundle

" man.vim: invoked by :Man {name}
source $VIMRUNTIME/ftplugin/man.vim

" let Vundle manage Vundle, required
" ---------------------------------------------------
Plugin 'gmarik/Vundle.vim'

"}}}

" general plugins {{{

let g:exlib = 1
if exists('g:exlib')
    " ex-config:
    " ---------------------------------------------------
    Plugin 'exvim/ex-config'
    nnoremap <unique> <leader>ve :call exconfig#edit_cur_vimentry ()<CR>

    " ex-utility:
    " ---------------------------------------------------
    Plugin 'exvim/ex-utility'

    nnoremap <unique> <silent> <Leader>bd :EXbd<CR>
    nnoremap <unique> <silent> <C-l> :EXbn<CR>
    nnoremap <unique> <silent> <C-h> :EXbp<CR>
    nnoremap <unique> <silent> <C-Tab> :EXbalt<CR>
    nnoremap <unique> <silent> <Leader><Tab> :EXsw<CR>
    nmap <unique> <silent> <Leader><Esc> :EXgp<CR><ESC>

    " ex-aftercolor
    " ---------------------------------------------------
    Plugin 'exvim/ex-aftercolors'

    " ex-vimentry
    " ---------------------------------------------------
    Plugin 'exvim/ex-vimentry'

    " ex-project
    " ---------------------------------------------------
    Plugin 'exvim/ex-project'

    " ex-gsearch
    " ---------------------------------------------------
    Plugin 'exvim/ex-gsearch'

    call exgsearch#register_hotkey( 100, 0, '<leader>gs', ":EXGSearchToggle<CR>", 'Toggle global search window.' )
    call exgsearch#register_hotkey( 101, 0, '<leader>gg', ":EXGSearchCWord<CR>", 'Search current word.' )
    call exgsearch#register_hotkey( 102, 0, '<leader><S-f>', ":GS ", 'Shortcut for :GS' )

    " ex-tagselect
    " ---------------------------------------------------
    Plugin 'exvim/ex-tags'

    call extags#register_hotkey( 100, 0, '<leader>ts', ":EXTagsToggle<CR>", 'Toggle tag select window.' )
    call extags#register_hotkey( 101, 0, '<leader>tt', ":EXTagsCWord<CR>", 'Tag select current word.' )
    " DISABLE: nnoremap <unique> <leader>] :exec 'ts ' . expand('<cword>')<CR>

    " ex-symbol
    " ---------------------------------------------------
    Plugin 'exvim/ex-symbol'

    call exsymbol#register_hotkey( 100, 0, '<leader>sl', ":EXSymbolList<CR>", 'List all symbols.' )
    call exsymbol#register_hotkey( 101, 0, '<leader>st', ":EXSymbolToggle<CR>", 'Open symbols window.' )
    call exsymbol#register_hotkey( 102, 0, '<leader>ss', ":EXSymbolCWord<CR>", 'List symbols contains current word.' )

    if has('gui_running')
        if has ('mac')
            call exsymbol#register_hotkey( 102, 0, 'Ã’', ":EXSymbolList<CR>:redraw<CR>/", 'List all symbols and stay in search mode.' )
        else
            call exsymbol#register_hotkey( 102, 0, '<M-L>', ":EXSymbolList<CR>:redraw<CR>/", 'List all symbols and stay in search mode.' )
        endif
    endif
    let g:ex_symbol_select_cmd = 'TS'

    " ex-cscope
    " ---------------------------------------------------
    Plugin 'exvim/ex-cscope'

    call excscope#register_hotkey( 100, 0, '<leader>cd', ":EXCSToggle<CR>", 'Toggle cscope window.' )

    " ex-qfix
    " ---------------------------------------------------
    Plugin 'exvim/ex-qfix'

    call exqfix#register_hotkey( 100, 0, '<leader>qf', ":EXQFixToggle<CR>", 'Toggle quickfix window.' )
    call exqfix#register_hotkey( 101, 0, '<leader>qq', ":EXQFixPaste<CR>", 'Open quickfix window and paste error list from register *.' )

    " ex-hierarchy
    " ---------------------------------------------------
    Plugin 'exvim/ex-hierarchy'

    nnoremap <unique> <leader>hv :EXHierarchyCWord<CR>

    " ex-taglist: invoke by <F4>
    " ---------------------------------------------------
    Plugin 'exvim/ex-taglist'

    " F4:  Switch on/off TagList
    nnoremap <unique> <silent> <F4> :TlistToggle<CR>

    let Tlist_Ctags_Cmd = $VIM.'/vimfiles/ctags.exe' " location of ctags tool 
    let Tlist_Show_One_File = 1 " Displaying tags for only one file~
    let Tlist_Exist_OnlyWindow = 1 " if you are the last, kill yourself 
    let Tlist_Use_Right_Window = 1 " split to the right side of the screen 
    let Tlist_Sort_Type = "order" " sort by order or name
    let Tlist_Display_Prototype = 0 " do not show prototypes and not tags in the taglist window.
    let Tlist_Compart_Format = 1 " Remove extra information and blank lines from the taglist window.
    let Tlist_GainFocus_On_ToggleOpen = 1 " Jump to taglist window on open.
    let Tlist_Display_Tag_Scope = 1 " Show tag scope next to the tag name.
    let Tlist_Close_On_Select = 0 " Close the taglist window when a file or tag is selected.
    let Tlist_BackToEditBuffer = 0 " If no close on select, let the user choose back to edit buffer or not
    let Tlist_Enable_Fold_Column = 0 " Don't Show the fold indicator column in the taglist window.
    let Tlist_WinWidth = 40
    let Tlist_Compact_Format = 1 " do not show help
    " let Tlist_Ctags_Cmd = 'ctags --c++-kinds=+p --fields=+iaS --extra=+q --languages=c++'
    " very slow, so I disable this
    " let Tlist_Process_File_Always = 1 " To use the :TlistShowTag and the :TlistShowPrototype commands without the taglist window and the taglist menu, you should set this variable to 1.
    ":TlistShowPrototype [filename] [linenumber]

    " add javascript language
    let tlist_javascript_settings = 'javascript;v:global variable:0:0;c:class;p:property;m:method;f:function;r:object'
    " add hlsl shader language
    let tlist_hlsl_settings = 'c;d:macro;g:enum;s:struct;u:union;t:typedef;v:variable;f:function'
    " add actionscript language
    let tlist_actionscript_settings = 'actionscript;c:class;f:method;p:property;v:variable'

    " DISABLE: use tlist instead
    " " exvim/ex-tagbar: invoke by <F4>
    " " ---------------------------------------------------
    " Plugin 'exvim/ex-tagbar'

    " nnoremap <unique> <silent> <F4> :TagbarToggle<CR>

    " let g:tagbar_sort = 0
    " let g:tagbar_map_preview = '<CR>'
    " if has('gui_running')
    "     let g:tagbar_map_close = '<Esc>' 
    " else
    "     let g:tagbar_map_close = '<leader><Esc>' 
    " endif
    " let g:tagbar_map_zoomwin = '<Space>' 
    " let g:tagbar_zoomwidth = 80
    " let g:tagbar_autofocus = 1
    " let g:tagbar_iconchars = ['+', '-']

    " " use command ':TagbarGetTypeConfig lang' change your settings 
    " let g:tagbar_type_javascript = {
    "     \ 'ctagsbin': 'ctags',
    "     \ 'kinds' : [
    "         \ 'v:global variables:0:0',
    "         \ 'c:classes',
    "         \ 'p:properties:0:0',
    "         \ 'm:methods',
    "         \ 'f:functions',
    "         \ 'r:object',
    "     \ ],
    " \ }
    " let g:tagbar_type_c = {
    "     \ 'kinds' : [
    "         \ 'd:macros:0:0',
    "         \ 'p:prototypes:0:0',
    "         \ 'g:enums',
    "         \ 'e:enumerators:0:0',
    "         \ 't:typedefs:0:0',
    "         \ 's:structs',
    "         \ 'u:unions',
    "         \ 'm:members:0:0',
    "         \ 'v:variables:0:0',
    "         \ 'f:functions',
    "     \ ],
    " \ }
    " let g:tagbar_type_cpp = {
    "     \ 'kinds' : [
    "         \ 'd:macros:0:0',
    "         \ 'p:prototypes:0:0',
    "         \ 'g:enums',
    "         \ 'e:enumerators:0:0',
    "         \ 't:typedefs:0:0',
    "         \ 'n:namespaces',
    "         \ 'c:classes',
    "         \ 's:structs',
    "         \ 'u:unions',
    "         \ 'f:functions',
    "         \ 'm:members:0:0',
    "         \ 'v:variables:0:0',
    "     \ ],
    " \ }


    " ex-autocomplpop: invoke when you input text
    " ---------------------------------------------------
    " Plugin 'exvim/ex-autocomplpop'

    " ex-showmarks: invoke by m... or <leader>mm, <leader>ma
    " ---------------------------------------------------
    Plugin 'exvim/ex-showmarks'

    " TODO: bootleq/ShowMarks on github is well organized in code, but have lots 
    " bugs, consider merge his code and fixes the bugs 
    let g:showmarks_enable = 1
    let g:showmarks_include = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
    let g:showmarks_ignore_type = 'hqm' " Ignore help, quickfix, non-modifiable buffers
    " Hilight lower & upper marks
    let g:showmarks_hlline_lower = 1
    let g:showmarks_hlline_upper = 0 

    " ex-visincr: invoke when select text and type ':II'
    " ---------------------------------------------------
    Plugin 'exvim/ex-visincr'

    " ex-matchit: invoke by %
    " ---------------------------------------------------
    Plugin 'exvim/ex-matchit'

    " ex-easyhl:
    " ---------------------------------------------------
    Plugin 'exvim/ex-easyhl'

    " searchcompl: invoke by /
    " ---------------------------------------------------
    Plugin 'exvim/ex-searchcompl'

    " ex-colorschemes
    " ---------------------------------------------------
    Plugin 'exvim/ex-colorschemes'

    " vim-color-solarized
    " ---------------------------------------------------
    Plugin 'altercation/vim-colors-solarized'
    " c-lang {{{

    " ex-cref: invoke by <leader>cr
    " ---------------------------------------------------
    Plugin 'exvim/ex-cref'

    " this is modified for default c syntax highlight settings 
    " make it don't highlight error pattern
    let c_gnu = 1
    let c_no_curly_error = 1
    let c_no_bracket_error = 1

    "}}}
    " tabular: invoke by <leader>= alignment-character
    " ---------------------------------------------------
    Plugin 'godlygeek/tabular'

    nnoremap <silent> <leader>= :call g:Tabular(1)<CR>
    xnoremap <silent> <leader>= :call g:Tabular(0)<CR>
    function! g:Tabular(ignore_range) range
        let c = getchar()
        let c = nr2char(c)
        if a:ignore_range == 0
            exec printf('%d,%dTabularize /%s', a:firstline, a:lastline, c)
        else
            exec printf('Tabularize /%s', c)
        endif
    endfunction
    " only supoort in 7.3 or higher
    if v:version >= 703
        set noacd " no autochchdir
    endif
else
    if v:version >= 703
        set acd " no autochchdir
    endif
endif
" vim-airline
" ---------------------------------------------------
Plugin 'bling/vim-airline'

if has('gui_running')
    let g:airline_powerline_fonts = 1
else
    let g:airline_powerline_fonts = 0
endif

let g:airline_theme = 'powerlineish'
let g:airline#extensions#tabline#enabled = 1 " NOTE: When you open lots of buffers and typing text, it is so slow.
let g:airline#extensions#tabline#show_buffers = 1
let g:airline#extensions#tabline#buffer_nr_show = 1
let g:airline#extensions#tabline#fnamemod = ':t'
" let g:airline_section_b = "%{fnamemodify(bufname('%'),':p:.:h').'/'}"
" let g:airline_section_c = '%t'
let g:airline_section_warning = airline#section#create(['syntastic'])

" ctrlp: invoke by <ctrl-p>
Plugin 'kien/ctrlp.vim'
let g:ctrlp_working_path_mode = ''
let g:ctrlp_match_window = 'bottom,order:ttb,min:1,max:10,results:10'
let g:ctrlp_follow_symlinks = 2
nnoremap <unique> <leader>bs :CtrlPBuffer<CR>

" nerdtree: invoke by :NERDTreeToggle
" ---------------------------------------------------
Plugin 'scrooloose/nerdtree'

let g:NERDTreeWinSize = 30
let g:NERDTreeMouseMode = 1
let g:NERDTreeMapToggleZoom = '<Space>' 
let g:nerdtree_tabs_open_on_gui_startup=0
" nerdcommenter: invoke by <leader>c<space>, <leader>cl, <leader>cu, <F11> or <C-F11>
" ---------------------------------------------------
Plugin 'scrooloose/nerdcommenter'

let g:NERDSpaceDelims = 1
let g:NERDRemoveExtraSpaces = 1
let g:NERDCustomDelimiters = {
            \ 'vimentry': { 'left': '--' },
            \ }
map <unique> <F11> <Plug>NERDCommenterAlignBoth
map <unique> <C-F11> <Plug>NERDCommenterUncomment

" syntastic: invoke when you save file and have syntac-checker
" ---------------------------------------------------
Plugin 'scrooloose/syntastic'

" this will make html file by Angular.js ignore errors
let g:syntastic_html_tidy_ignore_errors=[" proprietary attribute \"ng-"]

Plugin 'Shougo/neocomplete'
"Note: This option must set it in .vimrc(_vimrc).  NOT IN .gvimrc(_gvimrc)!
" Disable AutoComplPop.
let g:acp_enableAtStartup = 0
" Use neocomplete.
let g:neocomplete#enable_at_startup = 1
" Use smartcase.
let g:neocomplete#enable_smart_case = 1
" Set minimum syntax keyword length.
let g:neocomplete#sources#syntax#min_keyword_length = 3
let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'
" let g:neocomplete#max_list = 10
" Define dictionary.
let g:neocomplete#sources#dictionary#dictionaries = {
    \ 'default' : '',
    \ 'vimshell' : $HOME.'/.vimshell_hist',
    \ 'scheme' : $HOME.'/.gosh_completions'
        \ }

" Define keyword.
if !exists('g:neocomplete#keyword_patterns')
    let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns['default'] = '\h\w*'

" Plugin key-mappings.
inoremap <expr><C-g>     neocomplete#undo_completion()
inoremap <expr><C-l>     neocomplete#complete_common_string()

" Recommended key-mappings.
" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
  return neocomplete#close_popup() . "\<CR>"
  " For no inserting <CR> key.
  "return pumvisible() ? neocomplete#close_popup() : "\<CR>"
endfunction
" <TAB>: completion.
inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><C-y>  neocomplete#close_popup()
inoremap <expr><C-e>  neocomplete#cancel_popup()
" Close popup by <Space>.
"inoremap <expr><Space> pumvisible() ? neocomplete#close_popup() : "\<Space>"

" For cursor moving in insert mode(Not recommended)
"inoremap <expr><Left>  neocomplete#close_popup() . "\<Left>"
"inoremap <expr><Right> neocomplete#close_popup() . "\<Right>"
"inoremap <expr><Up>    neocomplete#close_popup() . "\<Up>"
"inoremap <expr><Down>  neocomplete#close_popup() . "\<Down>"
" Or set this.
"let g:neocomplete#enable_cursor_hold_i = 1
" Or set this.
"let g:neocomplete#enable_insert_char_pre = 1

" AutoComplPop like behavior.
"let g:neocomplete#enable_auto_select = 1

" Shell like behavior(not recommended).
"set completeopt+=longest
"let g:neocomplete#enable_auto_select = 1
"let g:neocomplete#disable_auto_complete = 1
"inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"

" Enable omni completion.
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

" Enable heavy omni completion.
if !exists('g:neocomplete#sources#omni#input_patterns')
  let g:neocomplete#sources#omni#input_patterns = {}
endif
"let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
"let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
"let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

" For perlomni.vim setting.
" https://github.com/c9s/perlomni.vim
let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
" DISABLE: use ex-autocomplpop instead
" " neocomplcache: invoke when you insert words
" Plugin 'Shougo/neocomplcache.vim'
" " ---------------------------------------------------

" let g:neocomplcache_enable_at_startup = 1
" let g:neocomplcache_auto_completion_start_length = 2
" let g:neocomplcache_enable_smart_case = 1
" let g:neocomplcache_enable_auto_select = 1 " let neocomplcache's completion behavior like AutoComplPop
" " let g:neocomplcache_disable_auto_complete = 1 " Enable this if you like TAB for complete
" " inoremap <C-p> <C-x><C-u>
" " inoremap <expr><TAB>  pumvisible() ? '\<Down>' : '<TAB>'
" " inoremap <expr><S-TAB>  pumvisible() ? '\<Up>' : ''

" DISABLE: use ex-autocomplpop instead
" " neocomplete: invoke when you insert words
" Plugin 'Shougo/neocomplete.vim'
" " ---------------------------------------------------

" let g:neocomplete#enable_at_startup = 1
" let g:neocomplete#enable_smart_case = 1
" let g:neocomplete#enable_auto_select = 1 " let neocomplete's completion behavior like AutoComplPop
" " Enable omni completion.
" autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
" autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
" autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
" autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
" autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

" DISABLE: use ex-autocomplpop instead
" " YouCompleteMe
" Plugin 'Valloric/YouCompleteMe'
" " ---------------------------------------------------

Plugin 'Shougo/vimproc'
" TODO: choose a snippet plugin
Plugin 'Shougo/neosnippet.vim'
Plugin 'Shougo/neosnippet-snippets'
" Plugin key-mappings.
imap <C-k>     <Plug>(neosnippet_expand_or_jump)
smap <C-k>     <Plug>(neosnippet_expand_or_jump)
xmap <C-k>     <Plug>(neosnippet_expand_target)

" SuperTab like snippets behavior.
imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)"
\: pumvisible() ? "\<C-n>" : "\<TAB>"
smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)"
\: "\<TAB>"

" For snippet_complete marker.
if has('conceal')
  set conceallevel=2 concealcursor=i
endif
" " ---------------------------------------------------

" Plugin 'msanders/snipmate.vim'
" " ---------------------------------------------------

" Plugin 'spf13/snipmate-snippets'
" " ---------------------------------------------------

" undotree: invoke by <Leader>u
" ---------------------------------------------------
Plugin 'mbbill/undotree'

nnoremap <leader>u :UndotreeToggle<CR>
let g:undotree_SetFocusWhenToggle=1
let g:undotree_WindowLayout = 4

" NOTE: this will prevent undotree closed then jump to minibufexpl
function! g:CloseUndotree()
    call UndotreeHide()
    call ex#window#goto_edit_window()
endfunction

function g:Undotree_CustomMap()
    if has('gui_running')
        nnoremap <silent> <script> <buffer> <ESC> :call g:CloseUndotree()<CR>
    else
        nnoremap <silent> <script> <buffer> <leader><ESC> :call g:CloseUndotree()<CR>
    endif
endfunction


" vim-easymotion: invoke by <leader><leader> w,b,e,ge,f,F,h,i,j,k,/ 
" ---------------------------------------------------
Plugin 'Lokaltog/vim-easymotion'

map <leader><leader>/ <Plug>(easymotion-sn)
omap <leader><leader>/ <Plug>(easymotion-tn)
map <leader><leader>j <Plug>(easymotion-j)
map <leader><leader>k <Plug>(easymotion-k)
map <leader><leader>l <Plug>(easymotion-lineforward)
map <leader><leader>h <Plug>(easymotion-linebackward)
let g:EasyMotion_startofline = 0 " keep cursor colum when JK motion

" LargeFile
" ---------------------------------------------------
Plugin 'vim-scripts/LargeFile'
let g:LargeFile= 5 " files >= 5MB will use LargeFile rules

"}}}

" DISABLE: I'm using GistBox https://app.gistboxapp.com/ instead
" " gist-vim: Invoke by :Gist
" ---------------------------------------------------
" Plugin 'mattn/webapi-vim'
" Plugin 'mattn/gist-vim'
Plugin 'tpope/vim-surround'
Plugin 'tpope/vim-repeat'

Plugin 'xolox/vim-misc'  " required by lua.vim
Plugin 'xolox/vim-lua-ftplugin'  " Lua file type plug-in for the Vim text editor
let g:lua_define_completefunc = 0
let g:lua_define_completion_mappings = 0

let g:haskell = 1
if exists('g:haskell')
    Plugin 'dag/vim2hs'
    let g:haskell_conceal = 0
    let g:haskell_conceal_enumerations = 0
    " Plugin 'travitch/hasksyn'
    " Plugin 'Twinside/vim-haskellConceal'
    " Plugin 'Twinside/vim-haskellFold'
    Plugin 'lukerandall/haskellmode-vim'
    let g:haddock_browser="firefox.exe"
    let g:haddock_docdir='C:\Program Files\Haskell Platform\2014.2.0.0\doc\html\'
    Plugin 'eagletmt/neco-ghc'
    Plugin 'eagletmt/ghcmod-vim'
    Plugin 'nbouscal/vim-stylish-haskell'
    " Use stylish haskell instead of par for haskell buffers
	autocmd FileType haskell let &formatprg="stylish-haskell"
    "Plugin 'Shougo/vimproc'
    " Plugin 'adinapoli/cumino'
    " Plugin 'bitc/vim-hdevtools'
    " Workaround vim-commentary for Haskell
    autocmd FileType haskell setlocal commentstring=--\ %s
    " Workaround broken colour highlighting in Haskell
    autocmd FileType haskell setlocal nospell
    autocmd FileType haskell setlocal omnifunc=necoghc#omnifunc
    " Type of expression under cursor
	nmap <silent> <leader>ht :GhcModType<CR>
	" Insert type of expression under cursor
	nmap <silent> <leader>hT :GhcModTypeInsert<CR>
    " if !executable("ghcmod")
        " autocmd BufWritePost *.hs GhcModCheckAndLintAsync
    " endif
endif

" let g:lua_define_omnifunc = 0
" vim:ts=4:sw=4:sts=4 et fdm=marker:
