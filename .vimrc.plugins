" Pathogen or Vundle (deafult is Vundle) {{{

" Comment-out if you want to use pahogen
" execute pathogen#infect()
" com! -nargs=+ Bundle

" man.vim: invoked by :Man {name}
source $VIMRUNTIME/ftplugin/man.vim

" let Vundle manage Vundle, required
" ---------------------------------------------------
Plugin 'gmarik/Vundle.vim'
Plugin 'MarcWeber/vim-addon-mw-utils'
Plugin 'tomtom/tlib_vim'

"}}}

Plugin 'rhysd/conflict-marker.vim'
"Plugin 'jiangmiao/auto-pairs'
Plugin 'terryma/vim-multiple-cursors'
Plugin 'vim-scripts/sessionman.vim'
" nmap <leader>sl :SessionList<CR>
" nmap <leader>ss :SessionSave<CR>
" nmap <leader>sc :SessionClose<CR>
Plugin 'matchit.zip'
Plugin 'nathanaelkane/vim-indent-guides'
" indent_guides {
let g:indent_guides_start_level = 2
let g:indent_guides_guide_size = 1
let g:indent_guides_enable_on_vim_startup = 1
" }
Plugin 'mhinz/vim-signify'
let g:signify_vcs_list = [ 'git']
Plugin 'tpope/vim-abolish.git'
Plugin 'osyo-manga/vim-over'

Plugin 'kana/vim-textobj-user'
Plugin 'kana/vim-textobj-indent'
Plugin 'reedes/vim-textobj-sentence'
augroup textobj_sentence
  autocmd!
  autocmd FileType markdown call textobj#sentence#init()
  autocmd FileType textile call textobj#sentence#init()
  autocmd FileType text call textobj#sentence#init()
augroup END

Plugin 'reedes/vim-textobj-quote'
augroup textobj_quote
    autocmd!
    autocmd FileType markdown call textobj#quote#init()
    autocmd FileType textile call textobj#quote#init()
    autocmd FileType text call textobj#quote#init({'educate': 0})
augroup END

Plugin 'gcmt/wildfire.vim'
" Wildfire {
let g:wildfire_objects = {
            \ "*" : ["i'", 'i"', "i)", "i]", "i}", "ip"],
            \ "html,xml" : ["at"],
            \ }
" }
" general plugins {{{

let g:exlib = 1
if exists('g:exlib')
    if exists('g:exvim_custom_path')
        let vimrc_plugins_ex = g:exvim_custom_path.'/.vimrc.ex'
    else
        let vimrc_plugins_ex = '~/.vimrc.ex'
    endif

    if filereadable(expand(vimrc_plugins_ex))
        exec 'source ' . fnameescape(vimrc_plugins_ex)
    endif
else
    if v:version >= 703
        set acd " no autochchdir
    endif
endif

" tabular: invoke by <leader>= alignment-character
" ---------------------------------------------------
Plugin 'godlygeek/tabular'

nmap <Leader>a& :Tabularize /&<CR>
vmap <Leader>a& :Tabularize /&<CR>
nmap <Leader>a= :Tabularize /^[^=]*\zs=<CR>
vmap <Leader>a= :Tabularize /^[^=]*\zs=<CR>
nmap <Leader>a=> :Tabularize /=><CR>
vmap <Leader>a=> :Tabularize /=><CR>
nmap <Leader>a: :Tabularize /:<CR>
vmap <Leader>a: :Tabularize /:<CR>
nmap <Leader>a:: :Tabularize /:\zs<CR>
vmap <Leader>a:: :Tabularize /:\zs<CR>
nmap <Leader>a, :Tabularize /,<CR>
vmap <Leader>a, :Tabularize /,<CR>
nmap <Leader>a,, :Tabularize /,\zs<CR>
vmap <Leader>a,, :Tabularize /,\zs<CR>
nmap <Leader>a<Bar> :Tabularizd /<Bar><CR>
vmap <Leader>a<Bar> :Tabularize /<Bar><CR>
nnoremap <silent> <leader>= :call g:Tabular(1)<CR>
xnoremap <silent> <leader>= :call g:Tabular(0)<CR>
function! g:Tabular(ignore_range) range
    let c = getchar()
    let c = nr2char(c)
    if a:ignore_range == 0
        exec printf('%d,%dTabularize /%s', a:firstline, a:lastline, c)
    else
        exec printf('Tabularize /%s', c)
    endif
endfunction

" vim-airline
" ---------------------------------------------------
Plugin 'bling/vim-airline'
Plugin 'vim-airline/vim-airline-themes'

if has('gui_running')
    let g:airline_powerline_fonts = 1
else
    let g:airline_powerline_fonts = 1
endif

let g:airline_theme = 'powerlineish'
let g:airline#extensions#tabline#enabled = 1 " NOTE: When you open lots of buffers and typing text, it is so slow.
let g:airline#extensions#tabline#show_buffers = 1
let g:airline#extensions#tabline#buffer_nr_show = 1
let g:airline#extensions#tabline#fnamemod = ':t'
" let g:airline_section_b = "%{fnamemodify(bufname('%'),':p:.:h').'/'}"
" let g:airline_section_c = '%t'
let g:airline_section_warning = airline#section#create(['syntastic'])

" ctrlp: invoke by <ctrl-p>
Plugin 'kien/ctrlp.vim'
Plugin 'tacahiroy/ctrlp-funky'
Plugin 'jasoncodes/ctrlp-modified.vim'
let g:ctrlp_working_path_mode = ''
let g:ctrlp_match_window = 'bottom,order:ttb,min:1,max:10,results:10'
let g:ctrlp_follow_symlinks = 2
let g:ctrlp_custom_ignore = {
    \ 'dir':  '\.git$\|\.hg$\|\.svn$',
    \ 'file':  '\v(\.cpp|\.h|\.hh|\.cxx|\.lua|\.c)@<!$'}
" CtrlP extensions
let g:ctrlp_extensions = ['funky']
let g:ctrlp_use_caching = 1

"funky
nnoremap <Leader>fm :CtrlPModified<CR>
nnoremap <Leader>fg :CtrlPBranch<CR>
nnoremap <Leader>fu :CtrlPFunky<Cr>
nnoremap <leader>fb :CtrlPBuffer<CR>
nnoremap <leader>fa :Ack<CR>

" vim-markdown
" Plugin 'plasticboy/vim-markdown'

" nerdtree: invoke by :NERDTreeToggle
" ---------------------------------------------------
Plugin 'scrooloose/nerdtree'
Plugin 'jistr/vim-nerdtree-tabs'

let g:NERDTreeWinSize = 30
let g:NERDTreeMouseMode = 1
let g:NERDTreeMapToggleZoom = '<Space>' 
let g:nerdtree_tabs_open_on_gui_startup=0
let NERDTreeIgnore=['\.py[cd]$', '\~$', '\.swo$', '\.swp$', '^\.git$', '^\.hg$', '^\.svn$', '\.bzr$']
map <leader>nn <plug>NERDTreeTabsToggle<CR>
map <F2> <plug>NERDTreeTabsToggle<CR>

" nerdcommenter: invoke by <leader>c<space>, <leader>cl, <leader>cu, <F11> or <C-F11>
" ---------------------------------------------------
Plugin 'scrooloose/nerdcommenter'
Plugin 'tpope/vim-commentary'

let g:NERDSpaceDelims = 1
let g:NERDRemoveExtraSpaces = 1
let g:NERDCustomDelimiters = {
            \ 'vimentry': { 'left': '--' },
            \ }
map <F11> <Plug>NERDCommenterAlignBoth
map <C-F11> <Plug>NERDCommenterUncomment

" syntastic: invoke when you save file and have syntac-checker
" ---------------------------------------------------
Plugin 'scrooloose/syntastic'

" this will make html file by Angular.js ignore errors
let g:syntastic_html_tidy_ignore_errors=[" proprietary attribute \"ng-"]

Plugin 'Shougo/neocomplete'
"Note: This option must set it in .vimrc(_vimrc).  NOT IN .gvimrc(_gvimrc)!
" Disable AutoComplPop.
let g:acp_enableAtStartup = 0
" Use neocomplete.
let g:neocomplete#enable_at_startup = 1
" Use smartcase.
let g:neocomplete#enable_smart_case = 1
" Set minimum syntax keyword length.
let g:neocomplete#sources#syntax#min_keyword_length = 3
let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'
" let g:neocomplete#max_list = 10
" Define dictionary.
let g:neocomplete#sources#dictionary#dictionaries = {
    \ 'default' : '',
    \ 'vimshell' : $HOME.'/.vimshell_hist',
    \ 'scheme' : $HOME.'/.gosh_completions',
    \ 'lua' : $HOME.'/.vim/bundle/vim-quick-community/key-dict'
        \ }
" Define keyword.
if !exists('g:neocomplete#keyword_patterns')
    let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns['default'] = '\h\w*'

" Plugin key-mappings.
inoremap <expr><C-g>     neocomplete#undo_completion()
inoremap <expr><C-l>     neocomplete#complete_common_string()

" Recommended key-mappings.
" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
  return neocomplete#close_popup() . "\<CR>"
  " For no inserting <CR> key.
  "return pumvisible() ? neocomplete#close_popup() : "\<CR>"
endfunction
" <TAB>: completion.
inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><C-y>  neocomplete#close_popup()
inoremap <expr><C-e>  neocomplete#cancel_popup()
" Close popup by <Space>.
"inoremap <expr><Space> pumvisible() ? neocomplete#close_popup() : "\<Space>"

" For cursor moving in insert mode(Not recommended)
"inoremap <expr><Left>  neocomplete#close_popup() . "\<Left>"
"inoremap <expr><Right> neocomplete#close_popup() . "\<Right>"
"inoremap <expr><Up>    neocomplete#close_popup() . "\<Up>"
"inoremap <expr><Down>  neocomplete#close_popup() . "\<Down>"
" Or set this.
"let g:neocomplete#enable_cursor_hold_i = 1
" Or set this.
"let g:neocomplete#enable_insert_char_pre = 1

" AutoComplPop like behavior.
"let g:neocomplete#enable_auto_select = 1

" Shell like behavior(not recommended).
"set completeopt+=longest
"let g:neocomplete#enable_auto_select = 1
"let g:neocomplete#disable_auto_complete = 1
"inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"

" Enable omni completion.
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

" Enable heavy omni completion.
if !exists('g:neocomplete#sources#omni#input_patterns')
  let g:neocomplete#sources#omni#input_patterns = {}
endif
"let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
"let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
"let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

" For perlomni.vim setting.
" https://github.com/c9s/perlomni.vim
let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
" DISABLE: use ex-autocomplpop instead
" " neocomplcache: invoke when you insert words
" Plugin 'Shougo/neocomplcache.vim'
" " ---------------------------------------------------

" let g:neocomplcache_enable_at_startup = 1
" let g:neocomplcache_auto_completion_start_length = 2
" let g:neocomplcache_enable_smart_case = 1
" let g:neocomplcache_enable_auto_select = 1 " let neocomplcache's completion behavior like AutoComplPop
" " let g:neocomplcache_disable_auto_complete = 1 " Enable this if you like TAB for complete
" " inoremap <C-p> <C-x><C-u>
" " inoremap <expr><TAB>  pumvisible() ? '\<Down>' : '<TAB>'
" " inoremap <expr><S-TAB>  pumvisible() ? '\<Up>' : ''

" DISABLE: use ex-autocomplpop instead
" " neocomplete: invoke when you insert words
" Plugin 'Shougo/neocomplete.vim'
" " ---------------------------------------------------

" let g:neocomplete#enable_at_startup = 1
" let g:neocomplete#enable_smart_case = 1
" let g:neocomplete#enable_auto_select = 1 " let neocomplete's completion behavior like AutoComplPop
" " Enable omni completion.
" autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
" autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
" autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
" autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
" autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

" DISABLE: use ex-autocomplpop instead
" " YouCompleteMe
" Plugin 'Valloric/YouCompleteMe'
" " ---------------------------------------------------

Plugin 'Shougo/vimproc'
" TODO: choose a snippet plugin
Plugin 'Shougo/neosnippet.vim'
Plugin 'Shougo/neosnippet-snippets'
" Plugin key-mappings.
imap <C-k>     <Plug>(neosnippet_expand_or_jump)
smap <C-k>     <Plug>(neosnippet_expand_or_jump)
xmap <C-k>     <Plug>(neosnippet_expand_target)

" SuperTab like snippets behavior.
imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)"
\: pumvisible() ? "\<C-n>" : "\<TAB>"
smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)"
\: "\<TAB>"

" For snippet_complete marker.
if has('conceal')
  set conceallevel=2 concealcursor=i
endif
" " ---------------------------------------------------
Plugin 'Konfekt/FastFold'
Plugin 'Konfekt/FoldText'

" Plugin 'msanders/snipmate.vim'
" " ---------------------------------------------------

" Plugin 'spf13/snipmate-snippets'
" " ---------------------------------------------------

" undotree: invoke by <Leader>u
" ---------------------------------------------------
Plugin 'mbbill/undotree'

nnoremap <leader>u :UndotreeToggle<CR>
let g:undotree_SetFocusWhenToggle=1
let g:undotree_WindowLayout = 4


" vim-easymotion: invoke by <leader><leader> w,b,e,ge,f,F,h,i,j,k,/ 
" ---------------------------------------------------
Plugin 'Lokaltog/vim-easymotion'
map f <Plug>(easymotion-prefix)
map ff <Plug>(easymotion-sn)
omap ff <Plug>(easymotion-tn)
map fj <Plug>(easymotion-j)
map fk <Plug>(easymotion-k)
map fl <Plug>(easymotion-lineforward)
map fh <Plug>(easymotion-linebackward)
map f. <Plug>(easymotion-repeat)
let g:EasyMotion_startofline = 0 " keep cursor colum when JK motion

" LargeFile
" ---------------------------------------------------
Plugin 'vim-scripts/LargeFile'
let g:LargeFile= 5 " files >= 5MB will use LargeFile rules

"}}}

" DISABLE: I'm using GistBox https://app.gistboxapp.com/ instead
" " gist-vim: Invoke by :Gist
" ---------------------------------------------------
" Plugin 'mattn/webapi-vim'
" Plugin 'mattn/gist-vim'
Plugin 'tpope/vim-surround'
Plugin 'tpope/vim-repeat'

Plugin 'xolox/vim-misc'  " required by lua.vim
Plugin 'xolox/vim-lua-ftplugin'  " Lua file type plug-in for the Vim text editor
Plugin 'tbastos/vim-lua'
let g:lua_define_completefunc = 0
let g:lua_define_completion_mappings = 0
let lua_version = 5
let lua_subversion = 1


Plugin 'tpope/vim-fugitive'
" nnoremap <silent> <leader>gs :Gstatus<CR>
nnoremap <silent> <leader>gd :Gdiff<CR>
nnoremap <silent> <leader>gc :Gcommit<CR>
nnoremap <silent> <leader>gb :Gblame<CR>
nnoremap <silent> <leader>gl :Glog<CR>
nnoremap <silent> <leader>gp :Git push<CR>
nnoremap <silent> <leader>gr :Gread<CR>
nnoremap <silent> <leader>gw :Gwrite<CR>
nnoremap <silent> <leader>ge :Gedit<CR>
" Mnemonic _i_nteractive
nnoremap <silent> <leader>gi :Git add -p %<CR>
" nnoremap <silent> <leader>gg :SignifyToggle<CR>

let g:haskell = 1
if exists('g:haskell')
    if exists('g:exvim_custom_path')
        let vimrc_plugins_haskell = g:exvim_custom_path.'/.vimrc.haskell'
    else
        let vimrc_plugins_haskell = '~/.vimrc.haskell'
    endif

    if filereadable(expand(vimrc_plugins_haskell))
        exec 'source ' . fnameescape(vimrc_plugins_haskell)
    endif
endif

" let g:lua_define_omnifunc = 0
" vim:ts=4:sw=4:sts=4 et fdm=marker:
